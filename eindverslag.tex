\documentclass[a4paper,11pt]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{amssymb}
\usepackage{color}
\newcommand{\tab}{\hspace*{2em}}

\title{Excel++}
\author{Bernd Kreynen 4331842\\
		Dave Grund 4291999\\
		Gerlof Fokkema 4257286\\
		Jente Hidskes 4335732\\
		Joris Lamers 4233042\\
		Skip Lentz 4334051\\
	   }

\begin{document}

\begin{titlepage}
\maketitle
\thispagestyle{empty} %geen page numbering op opening pagina
\end{titlepage}

\newpage\section{Algemeen: hoe het project is verlopen}\mbox{} \\
Over het algemeen is het project goed verlopen. Hier en daar zaten we een aantal keren vast, moest er even goed worden nagedacht over de juiste aanpak of ging er iets mis met GitHub, maar niks dat niet overkomen kon worden. Iedereen was tevreden met zijn taak, overleg plegen en planningen maken ging altijd goed en ook de communicatie met de student assistent was leuk. Wij zijn dan ook erg tevreden met het eindresultaat en de groep waarin wij zaten.\\

Van begin af aan was er in onze groep een duidelijke taakverdeling: de groep van zes is opgesplitst in tweetallen met ieder hun eigen taak. Zo werkte één tweetal aan de XML-reader en -writer en de formules, werkte een ander tweetal aan de parser voor de formules en de implementatie van Cellen en werkte het laatste tweetal aan de GUI. Doordat er zo’n duidelijke taakverdeling was, werd het hele project overzichtelijk en was het makkelijk om overleg te voeren. Er werd eerst overleg gepleegd binnen het tweetal en daarna over de conclusies van de andere tweetallen. Zo zijn eindeloze discussies en het tegelijkertijd implementeren van dezelfde feature voorkomen.\\

Helemaal in het begin, bij de eerste meeting, is er overleg gepleegd over wat voor features Excel++ moest hebben. Daarna is de taakverdeling gemaakt, onder andere gebaseerd op ervaring die sommige teamleden al hadden: Gerlof heeft al \textit{"real world"} ervaring met programmeren dus zou hij de formule parser en de implementatie op zich nemen, omdat dit een kritiek onderdeel van elk Spreadsheet programma is. Jente had al ervaring met GUI’s maken (GTK+ toolkit op Linux), dus nam hij dit onderdeel voor zijn rekening. Tot slot had Joris al ervaring met XML bestanden, omdat hij webdeveloper is naast student.\\

De gemaakte planningen waren eenvouding: \textit{"het grondwerk voor feature X is nu gelegd, dus volgende week is dat op zijn minst basaal geïmplementeerd"}. Zo zijn we iedere week bij elkaar gekomen om te kijken waar we nu waren, wat er nog moest gebeuren en welke features nu aan de beurt waren. Logischerwijs moest er met sommige features gewacht worden totdat anderen waren gedaan, maar dit was geen probleem. De hele groep hield zich aan de planning en er is nooit een periode geweest dat het ene tweetal moest wachten op het andere. Dit had tot gevolg dat iedereen op zijn eigen tempo door kon werken en dat steeds elke planning zoals gepland doorlopen werd.\\

Overleg plegen gebeurde voornamelijk via Facebook; hier hebben bij een speciale, private pagina op aangemaakt voor onze groep. Meer richting het einde werd er ook gebruikt gemaakt van de Issues op GitHub, maar deze diende voornamelijk als bugtracker en niet voor het overleggen over bijvoorbeeld welke toolkit er gekozen moest worden. Er is voor Facebook gekozen omdat iedereen hier toch wel dagelijks even naar kijkt en dit bij bijvoorbeeld email niet het geval is. Als het GUI-team een nieuwe methode nodig had van de klasse Cel of een wijziging in het TableModel, is het erg fijn als dit nog diezelfde middag gedaan kan worden. Via Facebook was dit mogelijk. Facebook bleek ook handig voor het terugkijken op eerder gemaakte beslissingen: alles is handig op chronologische volgorde terug te vinden, met de reacties van groepsleden erbij. Zoals gezegd is er ook gebruik gemakt van de Issues pagina van GitHub als bugtracker. Deze pagina is erg handig voor het centraal bijhouden van bugs of nog missende features. Ook hier is wel enig overleg gepleegd, wat wel resulteerde tot twee plaatsen van overleg en dus soms wel enig zoekwerk naar de juiste informatie. Een leuke bijkomendheid van de Issues is de drang die je hebt om het aantal geopende Issues zo laag mogelijk te houden: zo word je nog gemotiveerder om bugs te squashen!\\

Het gebruik van Git was niet alleen handig vanwege GitHub’s Issues pagina. Er is in onze groep veelvuldig gebruik gemaakt van branches, van Git’s rebase mogelijkheid en om simpelweg een commit te kunnen reverten. Tot twee keer toe was er een probleem met de master repository, maar mede dankzij de lokale kopieën zijn we altijd in staat geweest om dit op te lossen. De mogelijkheid om \textit{diff’s} van elke commit na te kijken is ook erg handig om te zien wat er precies is veranderd. Dit biedt de mogelijkheid om te zien of iets niet beter op een andere manier gedaan had kunnen worden. Er kan dus geconcludeerd worden dat het gebruik van versiebeheer ons zeker heeft geholpen!\\

\newpage\section{Ontwerpproces}\mbox{} \\
Gedurende het ontwerpproces zijn er verschillende momenten geweest waarop een aantal belangrijke ontwerpbeslissingen zijn genomen. Sommige van deze beslissingen bleken achteraf niet de juiste keuze. Wij zullen hier een aantal van deze beslissingen toelichten en bespreken. Bij het nemen van beslissingen hebben we zoveel mogelijk rekening gehouden met voornamelijk de volgende aspecten:
\begin{itemize}
	\item platform onafhankelijkheid;
	\item beschikbaarheid documentatie;
	\item performance en geheugengebruik;
	\item gemak van gebruik.
\end{itemize}

In het begin van het project dienden we gelijk twee belangrijke technologische afwegingen te maken, namelijk welke libraries we zouden gebruiken voor het uitlezen en het wegschrijven van de XML bestanden en voor het weergeven van de Graphical User Interface (GUI).\\

\subsection{De XML-reader en -writer}\mbox{} \\
De technologische afweging de hier gemaakt moest worden was welke API er gebruikt zou worden voor het uitlezen van XML bestanden: JAXP DOM of JAXP SAX. Van deze twee APIs, die beiden binnen de standaard API van Java zitten, zijn de voor- en nadelen onderzocht:
\begin{description}
	\item JAXP DOM
		\begin{description}
			\item[+] Makkelijk in gebruik omdat de hele XML als DOM model in het geheugen staat;
			\item[+] Makkelijk in gebruik door \textit{"DOM traversal"};
			\item[+] Kan ook gebruikt worden voor het wegschrijven van XML bestanden;
			\item[-] Verbruikt meer geheugen omdat de hele XML als DOM model in het geheugen staat;
			\item[-] Is minder snel en efficient dan een event based XML parser.
		\end{description}
	\item JAXP SAX
		\begin{description}
			\item[+] Sneller, vooral bij grote bestanden;
			\item[+] Verbruikt minder geheugen;
			\item[-] Lastiger te implementeren in verband met callbacks;
			\item[-] Kan niet gebruikt worden voor het wegschrijven van XML bestanden.
		\end{description}
\end{description}

De belangrijkste argumenten voor het gebruik van JAXP SAX zijn dus voornamelijk de snelheid en het geheugengebruik. Hiertegenover staan de belangrijkste argumenten voor het gebruik van JAXP DOM, namelijk het gebruiksgemak en het kunnen wegschrijven van bestanden met dezelfde library. Na het programmeren van een kleine testcase bleek het snelheidsverschil niet groot genoeg voor JAXP SAX en dus hebben we gekozen voor JAXP DOM, daar deze library nu de meeste voordelen heeft.

\subsection{De grafische toolkit}\mbox{} \\
De technologische afweging die hier gemaakt moest worden was welke toolkit er gebruikt zou worden voor de Grafische User Interface. Er waren vier gangbare keuzes: JavaFX, SWT, AWT en Swing. Hiervan is SWT gemaakt door de ontwikkelaars van Eclipse (ten behoeve van de Eclipse IDE) en de rest door de ontwikkelaars van Java. Ondanks dat JavaFX dus intern ontwikkeld is, wordt het niet standaard meegeleverd bij de Java Development Kit. Op dit moment wordt Swing gezien als "de standaard" voor het programmeren van GUI's met Java. Swing bouwt tevens voort op AWT, dat hierdoor eigenlijk al door ons werd afgeschreven.\\

Ook van al deze toolkits zijn de voor- en nadelen onderzocht, die hier onder kort worden samengevat:\\
\begin{description}
	\item Swing
		\begin{description}
			\item[+] Gedraagt zich op alle platformen vrijwel hetzelfde;
			\item[+] Wordt gezien als "de standaard";
			\item[+] Er is uitgebreide documentatie, inclusief vele tutorials, beschikbaar;
			\item[+] Komt intuïtief over.
		\end{description}
	\item AWT
		\begin{description}
			\item[-] Gedraagt zich niet helemaal hetzelfde op alle platformen;
			\item[-] Wordt tegenwoordig minder gebruikt dan Swing;
			\item[-] Kan als "verouderd" worden beschouwd, waarvan Swing de "opvolger" is.
		\end{description}
	\item SWT
		\begin{description}
			\item[-] Gedraagt zich niet helemaal hetzelfde op alle platformen;
			\item[-] Komt weinig intuïtief over;
			\item[-] Wordt relatief minder gebruikt dan Swing.
		\end{description}
	\item JavaFX
		\begin{description}
			\item[+] Ziet er grafisch erg mooi uit;
			\item[+] Is nog redelijk nieuw en daarmee minder uitgebreid getest;
			\item[+] Is meer bedoeld voor webapplicaties;
			\item[+] Wordt relatief minder gebruikt dan Swing.
		\end{description}
\end{description}

Omdat binnen onze groep alle drie de gangbare Operating Systems wordt gebruikt, is platform onafhankelijkheid een erg belangrijk argument geweest. Hierdoor zijn SWT en AWT afgevallen. JavaFX is nog relatief nieuw, wat tot gevolg heeft dat het weinig documentatie en voorbeelden heeft. Aangezien dit onze eerste ervaring met het programmeren van GUI's (dan al niet in Java) is, heeft dit ook een grote invloed op onze keuze gehad.\\

Om deze redenen hebben wij de conclusie getrokken dat geen van de alternatieven ons tijdens het ontwikkelen van Excel++ genoeg voordelen biedt om af te wijken van de "standaard": Swing.\\

\subsection{De plugin architectuur van de formules}\mbox{}\\
Ons programma Excel++ dient op zijn minst vijfentwintig verschillende functies te ondersteunen. Bij hebben gestreefd naar een modulair programma en daarom is het wenselijk dat we ook deze formules op zich zelf staand toe kunnen voegen aan het programma. Andy Zaidman heeft tijdens één van de lectures geopperd om dit te doen middels een "plugin architectuur".\\

Wij hebben ervoor gekozen om dit in ons programma te implementeren door op basis van input van de gebruiker dynamisch een formule-klasse in te laden. Op deze manier hoeft er bij het toevoegen van een nieuwe formule enkel een nieuwe klasse aangemaakt te worden in het juiste package. Na het toevoegen van de klasse zal de functie automatisch beschikbaar zijn in Excel++.\\

\subsection{De overstap van de infix parser naar de shunting-yard parser}\mbox{}\\
De eerste versie van onze Parser evalueerde direct vanuit de gegeven wiskunde expressie. Deze expressie is gegeven in "infix" notatie, de notatie die de meeste mensen gewend zijn.\\

Het probleem was echter dat het implementeren van de wiskundige bewerkingsvolgorde lastig was: het resulteerde in code dat methoden aanriep in methoden. Hierdoor was de code uiteindelijk lastig te begrijpen, waardoor het optimaliseren van de code en het fixen van bugs automatisch ook lastig werd. Om die reden zijn we overgestapt naar een ander soort Parser, waarbij we eerst de expressie omzetten naar "Reverse Polish Notation", ook wel "postfix" notatie. Deze expressie is makkelijker en sneller te evalueren dan een expressie in de "infix" notatie. Het omzetten zelf hebben we gedaan met behulp van het Shunting-yard algoritme, uitgevonden door E.W. Dijkstra. Met het evalueren van de nieuw verkregen expressie hoeven we geen rekening meer te houden met de wiskundige bewerkingsvolgorde, behalve bij expressies tussen haakjes.\\

Ook zijn we overgestapt naar het gebruiken van een state machine in plaats van regex patronen bij het "tokenization" proces. 
Het is bekend dat regex zeer traag is, maar aan de andere kant erg simpel is te implementeren. 
We hadden daarom vanaf het begin regex gebruikt, en we zouden overstappen op een andere manier van "tokenizen" als we tijd over hadden.

\subsection{De overstap van het String datatype naar het Cell datatype}\mbox{}\\
Voor het representeren van spreadsheet data hebben wij een klasse SpreadSheet ontwikkeld gebaseerd op het AbstractTableModel van Java Swing.
Deze klasse houdt referenties naar alle Cell objecten bij en biedt de GUI de mogelijkheid om waarden op te vragen.
De standaard AbstractTableModel API biedt echter enkel methoden zodat er omgegaan kan worden met het datatype Object.
Daarnaast biedt JTable de mogelijkheid om een CellRenderer en een CellEditor in te stellen.
Er wordt standaard echter alleen een CellRenderer en een CellEditor voor het omgaan met Strings meegeleverd.
Doordat de JTable en het AbstractTableModel enkel met Objects / Strings om kunnen gaan hebben we niet de mogelijkheid om opmaak in te stellen voor Cellen in onze datarepresentatie.
Daarom hebben wij ervoor gekozen om een eigen CellRenderer en CellEditor te ontwikkelen en om binnen het AbstractTableModel enkel gebruik te maken van Cells.
Op deze manier kunnen we in de GUI makkelijk Cell objecten aanvragen en van de Cell objecten zelf de opmaak wijzigen.
Omdat de Cell hierdoor verantwoordelijk is voor het opslaan van zijn eigen opmaak blijft het correct wegschrijven van Cell eigenschappen, zoals inhoud en opmaak, bovendien eenvoudig.

\subsection{De overstap van Double naar Object in de formule parser}\mbox{}\\
Tijdens het begin van het project hebben wij ervoor gekozen om ons te richten op een goede basis voor het programma. Dit betekende onder andere dat we wel een aantal van de ondersteunde formules hadden geimplementeerd, maar nog lang niet alles. Daardoor kwamen we vrij laat tot de conclusie dat onze formule Parser niet alleen het inlezen van Doubles moest ondersteunen, maar ook ook het inlezen van Strings. Een aantal functies kunnen ook Strings als argument meegegeven krijgen, of String returnen, de functie LOWER bijvoorbeeld. Om dit probleem op te lossen hebben we besloten om de functie Parser te baseren op Object in plaats van op Double. Hierdoor kunnen we de Parser Strings en Doubles laten genereren en laten opslaan als een Object. De formule beslist later zelf met behulp van 'instanceof' of zijn argumenten een String, een Int of een Double zijn.

\subsection{De modulaire structuur van de Writer-klasse}\mbox{}\\
Omdat het AbstractTableModel SpreadSheet de data representatie van onze spreadsheet bevat hebben we in eerste instantie ook de output van XML onderdeel gemaakt van de klasse SpreadSheet. Dit paste echter niet goed goed in ons streven om Excel++ zoveel mogelijk modulair te houden. Bovendien zou dit het toevoegen van ondersteuning voor andere bestandstypen lastig maken. Dit is de reden geweest om het wegschrijven van XML files ook modulair te maken. We hebben ervoor gekozen om de klasse SpreadSheet te laten communiceren met een Writer interface. De XML Writer implementeert vervolgens deze interface. Om ondersteuning voor eventuele extra Writers toe te voegen hoeven nu alleen de Writer interface te implementeren. Als demonstratie van deze Writer interface hebben we de extra Writer SysOutWriter toegevoegd, en indien mogelijk wordt voor het einde van het project nog ondersteuning voor CSV files toegevoegd.

\subsection{De grafieken: welke library?}\mbox{}\\
\begin{description}
	\item BIRT
		\begin{description}
			\item[+] Heel veel verschillende functionaliteiten (en dus ook al degene die wij nodig hebben);
			\item[-] Niet intuïtief.
		\end{description}
	\item JFreechart
		\begin{description}
			\item[+] Heel veel verschillende functionaliteiten (en dus ook al degene die wij nodig hebben);
			\item[+] Intuïtief en duidelijk.
		\end{description}
\end{description}

De beslissing tussen JFreechart en BIRT kwam dus neer op hoe makkelijk de beiden libraries te begrijpen waren. Beide konden alles wat we in onze applicatie nodig hadden maar JFreechart kon veel sneller geïmplementeerd worden omdat de basis van JFreechart makkelijker te begrijpen is.

\subsection{Het nut van het UML-diagram}\mbox{}\\
Een aantal van de genomen beslissingen hebben een grote impact gehad op het ontwerp van ons programma. Vooral ook de beslissingen die later genomen waren, nadat we meer kennis opgedaan hadden, hebben af en toe flinke gevolgen gehad. Twee voorbeelden hiervan zijn bijvoorbeeld het switchen van String naar Cell in het spreadsheet model en het switchen van Doubles naar Objects in de formule parser. Tijdens deze beslissingen heeft de UML ons geholpen om het overzicht op het ontwerp van het programma te behouden. Dankzij de UML was snel inzichtelijk wat voor impact dit soort wijzigingen op ons programma gingen hebben en waar we tegen problemen aan zouden lopen. Verder is het dankzij de UML ook makkelijk om uit te leggen aan de groep waar je precies aan werkt.
Een probleem waar we tegenaan gelopen zijn is dat het updaten van de UML niet altijd even frequent gedaan werd. Dit was echter geen probleem, omdat door onze taakverdeling iedereen zijn taak duidelijk was en de globale structuur van Excel++ wel altijd overeen kwam met die van het UML-diagram. Er werd wel voor gezorgd dat de structuur na ingrijpende wijzigingen weer klopte.
\end{document}
