//////////////////////////////////////////////////////////////////
/// WORK IN PROGRESS /// WORK IN PROGRESS /// WORK IN PROGRESS ///
//////////////////////////////////////////////////////////////////

========================
=== 2. Ontwerpproces ===
========================
Gedurende het ontwerpproces zijn er verschillende momenten geweest waarop een aantal belangrijke ontwerpbeslissingen zijn genomen. Sommige van deze beslissingen bleken achteraf niet de juiste keuze. Wij zullen hier een aantal van deze beslissingen toelichten en bespreken. Bij het nemen van beslissingen hebben we zoveel mogelijk rekening gehouden met voornamelijk de volgende aspecten:
- platform onafhankelijkheid
- beschikbaarheid documentatie
- performance en geheugengebruik
- gemak van gebruik


In het begin van het project dienden we gelijk 2 belangrijke technologische afwegingen te maken, namelijk welke libraries we zullen gebruiken voor het uitlezen en wegschrijven van XML en voor het weergeven van de Graphical User Interface (GUI).

+++++++++++++++++++++++++++
+++ XML reader / writer +++
+++++++++++++++++++++++++++
Technologische afweging:
Binnen de standaard API van Java zijn er 2 veelgebruikte APIs voor het uitlezen van XML bestanden, namelijk:
- JAXP DOM
- JAXP SAX
Daarnaast is er eigenlijk maar 1 gangbare API voor het wegschrijven van XML, namelijk:
- JAXP DOM

Van deze APIs hebben we de voor- en nadelen onderzocht.
JAXP DOM
+ makkelijk in gebruik omdat de hele XML als DOM model in het geheugen staat
+ makkelijk in gebruik door 'DOM traversal'
+ kan ook gebruikt worden voor het wegschrijven van XML
- verbruikt meer geheugen omdat de hele XML als DOM model in het geheugen staat
- is minder snel en efficient dan een event based XML parser

JAXP SAX
+ sneller, vooral bij grote files
+ verbruikt minder geheugen
- lastiger te implementeren ivm callbacks (event based)
- kan niet gebruikt worden voor het wegschrijven van XML

De belangrijkste argumenten voor het gebruik van JAXP SAX zijn dus voornamelijk de snelheid en het geheugengebruik. Daarnaast zijn de belangrijkste argumenten voor het gebruik van JAXP DOM het gebruiksgemak en het kunnen wegschrijven van files met dezelfde library. Na het programmeren van een testcase bleek het snelheidsverschil voor ons niet groot genoeg en hebben we voor gebruiksgemak gekozen.

++++++++++++++++++++++++++++
+++ JavaFX / SWT / Swing +++
++++++++++++++++++++++++++++
Technologische afweging:
Voor het programmeren van GUIs biedt Java zelf AWT, Swing en JavaFX. Daarnaast biedt Eclipse nog SWT. Ondanks dat JavaFX door Java zelf is ontwikkeld wordt het, net als SWT, niet standaard meegeleverd bij de Java Development Kit (JDK). Swing wordt op dit moment gezien als 'de standaard' voor het programmeren van GUI's. Daarnaast bouwt Swing voort op AWT. De nieuwste API van Java is JavaFX. Verder is SWT ontwikkeld door Eclipse ten behoeve van de Eclipse IDE.

Verder bieden ze de volgende voor- en nadelen.
Swing
+ gedraagt zich op alle platformen vrijwel hetzelfde
+ wordt gezien als 'standaard'
+ er is uitgebreide documentatie beschikbaar

AWT
- gedraagt zich niet helemaal hetzelfde op alle platformen
- wordt relatief minder gebruikt dan Swing

SWT
- gedraagt zich niet helemaal hetzelfde op alle platformen
- komt weinig intuïtief over
- wordt relatief minder gebruikt dan Swing

JFX
+ ziet er grafisch erg mooi uit
- is nog redelijk nieuw en daarmee minder uitgebreid getest
- meer voor webapplicaties
- wordt relatief minder gebruikt dan Swing

Omdat binnen onze groep alle 3 de gangbare operating systems gebruikt. Platform onafhankelijkheid is daarom een belangrijk argument voor ons. Daarom zijn SWT en AWT afgevallen. Verder JavaFX nog relatief nieuw. Hierdoor is het aantal voorbeelden en de hoeveelheid documentatie beschikbaar op het internet een stuk kleiner. Aangezien dit onze eerste ervaring met het programmeren van GUI's is heeft dit een grote invloed gehad op onze keuze.
Om deze redenen hebben wij de conclusie getrokken dat geen van de alternatieven ons tijdens het ontwikkel van Excel++ genoeg voordelen biedt om af te wijken van de 'standaard' Swing.

+++++++++++++++++++++++++++++++++++
+++ Plugin architectuur formula +++
+++++++++++++++++++++++++++++++++++
probleem:
Ons programma Excel++ dient op zijn minst 30 verschillende functies te ondersteunen. Om het ontwerp van ons programma modulair te houden is het wenselijk dat we ook deze formules op zichzelf staand toe kunnen voegen aan het programma. Andy Zaidman heeft tijdens één van zijn lectures geopperd om dit te doen middels een 'plugin architectuur'.
Wij hebben ervoor gekozen om dit in ons programma te implementeren door op basis van input van de user dynamisch een formule klasse in te laden. Op deze manier hoeft er bij het toevoegen van een nieuwe formule enkel een nieuwe klasse aangemaakt te worden in het juiste package. Na het toevoegen van de klasse zal de functie automatisch beschikbaar zijn in Excel++.

++++++++++++++++++++++++++++++++++++++++++++
+++ infix parser -> shunting-yard parser +++
++++++++++++++++++++++++++++++++++++++++++++
probleem:
De eerste versie van onze Parser evalueerde direct vanuit de gegeven wiskunde expressie. Deze expressie is gegeven in "infix" notatie, de notatie die de meeste mensen gewend zijn. 
Het probleem was echter dat het implementeren van de wiskundige bewerkingsvolgorde lastig was. 
Het resulteerde in code dat methoden aanriep in methoden. 
Hierdoor was de code uiteindelijk lastig te begrijpen, waardoor het optimaliseren van de code en het fixen van bugs automatisch ook lastig werd.
Om die reden zijn we overgestapt naar een ander soort Parser, waarbij we eerst de expressie omzetten naar "Reverse Polish Notation", ook wel "postfix" notatie. 
Deze expressie is makkelijker en sneller te evalueren dan een expressie in de "infix" notatie. Het omzetten zelf hebben we gedaan met behulp van het Shunting-yard algoritme, uitgevonden door E.W. Dijkstra.
Met het evalueren van de nieuw verkregen expressie hoeven we geen rekening meer te houden met de wiskundige bewerkingsvolgorde, behalve bij expressies tussen haakjes.

Ook zijn we overgestapt naar het gebruiken van een state machine in plaats van regex patronen bij het "tokenization" proces. 
Het is bekend dat regex zeer traag is, maar aan de andere kant erg simpel is te implementeren. 
We hadden daarom vanaf het begin regex gebruikt, en we zouden overstappen op een andere manier van "tokenizen" als we tijd over hadden.



++++++++++++++++++++++++++++++++++++++++
+++ String datatype -> Cell datatype +++
++++++++++++++++++++++++++++++++++++++++
probleem:
Voor het representeren van spreadsheet data hebben wij een klasse SpreadSheet ontwikkeld gebaseerd op het AbstractTableModel van Java Swing.
Deze klasse houdt referenties naar alle Cell objecten bij en biedt de GUI de mogelijkheid om waarden op te vragen.
De standaard AbstractTableModel API biedt echter enkel methoden zodat er omgegaan kan worden met het datatype Object.
Daarnaast biedt JTable de mogelijkheid om een CellRenderer en een CellEditor in te stellen.
Er wordt standaard echter alleen een CellRenderer en een CellEditor voor het omgaan met Strings meegeleverd.
Doordat de JTable en het AbstractTableModel enkel met Objects / Strings om kunnen gaan hebben we niet de mogelijkheid om opmaak in te stellen voor Cellen in onze datarepresentatie.
Daarom hebben wij ervoor gekozen om een eigen CellRenderer en CellEditor te ontwikkelen en om binnen het AbstractTableModel enkel gebruik te maken van Cells.
Op deze manier kunnen we in de GUI makkelijk Cell objecten aanvragen en van de Cell objecten zelf de opmaak wijzigen.
Omdat de Cell hierdoor verantwoordelijk is voor het opslaan van zijn eigen opmaak blijft het correct wegschrijven van Cell eigenschappen, zoals inhoud en opmaak, bovendien eenvoudig.

+++++++++++++++++++++++++++++++++++
+++ Writer: modulaire structuur +++
+++++++++++++++++++++++++++++++++++
technologisch afweging:
Omdat het AbstractTableModel SpreadSheet de data representatie van onze spreadsheet bevat hebben we in eerste instantie ook de output van XML onderdeel gemaakt van de klasse SpreadSheet.
Dit paste echter niet goed goed in ons streven om Excel++ zoveel mogelijk modulair te houden. Bovendien zou dit het toevoegen van ondersteuning voor andere bestandstypen lastig maken.
Dit is de reden geweest om het wegschrijven van XML files ook modulair te maken. We hebben ervoor gekozen om de klasse SpreadSheet te laten communiceren met een Writer interface.
De XML Writer implementeert vervolgens deze interface. Om ondersteuning voor eventuele extra Writers toe te voegen hoeven nu alleen de Writer interface te implementeren.
Als demonstratie van deze Writer interface hebben we de extra Writer SysOutWriter toegevoegd, en indien mogelijk wordt voor het einde van het project nog ondersteuning voor CSV files toegevoegd.

+++++++++++++++++++++++++
+++ JFreechart / BIRT +++
+++++++++++++++++++++++++
technologisch afweging:
BIRT:
+ Heel veel verschillende functionaliteiten (en dus ook al degene die wij nodig hebben)
- Niet intuïtief
JFreechart:
+ Heel veel verschillende functionaliteiten (en dus ook al degene die wij nodig hebben)
+ Intuïtief en duidelijk

De beslissing tussen JFreechart en BIRT kwam dus neer op hoe makkelijk de beiden libraries te begrijpen waren. 
Beide konden alles wat we in onze applicatie nodig hadden maar JFreechart kon veel sneller geïmplementeerd worden 
omdat de basis van JFreechart makkelijker te begrijpen is.

++++++++++++++++++++++++++++++++++++
+++ Parser:	Double -> Object +++
++++++++++++++++++++++++++++++++++++
probleem:
Tijdens het begin van het project hebben wij ervoor gekozen om ons te richten op een goede basis voor het programma. Dit betekende onder andere dat we wel een aantal van de ondersteunde formules hadden geimplementeerd, maar nog lang niet alles. Daardoor kwamen we vrij laat tot de conclusie dat onze formule Parser niet alleen het inlezen van Doubles moest ondersteunen, maar ook ook het inlezen van Strings. Een aantal functies kunnen ook Strings als argument meegegeven krijgen, of String returnen, de functie LOWER bijvoorbeeld. Om dit probleem op te lossen hebben we besloten om de functie Parser te baseren op Object in plaats van op Double. Hierdoor kunnen we de Parser Strings en Doubles laten genereren en laten opslaan als een Object. De formule beslist later zelf met behulp van 'instanceof' of zijn argumenten een String, een Int of een Double zijn.


++++++++++++++++++++++
+++ Het nu van UML +++
++++++++++++++++++++++
Een aantal van de genomen beslissingen hebben een grote impact gehad op het ontwerp van ons programma. Vooral ook de beslissingen die later genomen waren, nadat we meer kennis opgedaan hadden, hebben af en toe flinke gevolgen gehad. Twee voorbeelden hiervan zijn bijvoorbeeld het switchen van String naar Cell in het spreadsheet model en het switchen van Doubles naar Objects in de formule parser. Tijdens deze beslissingen heeft de UML ons geholpen om het overzicht op het ontwerp van het programma te behouden. Dankzij de UML was snel inzichtelijk wat voor impact dit soort wijzigingen op ons programma gingen hebben en waar we tegen problemen aan zouden lopen. Verder is het dankzij de UML ook makkelijk om uit te leggen aan de groep waar je precies aan werkt.
Een probleem waar we tegenaan gelopen zijn is dat het updaten van de UML niet altijd even frequent gedaan werd. De globale structuur van Excel++ kwam wel altijd overeen met het UML diagram, en er werd ook voor gezorgd dat de structuur na ingrijpende wijzigingen weer klopte.
